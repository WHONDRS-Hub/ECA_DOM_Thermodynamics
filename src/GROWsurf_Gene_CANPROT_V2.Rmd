---
title: "Running canprot on GROW - Genes"
author: "RED"
date: "2024-07-25"
output: html_document
---

This Rmarkdown is an alternative version of my CANPROT script that leverages the annotations and gene-calls from GROW, rather than my own personal prodigal calls. In practice, there shouldn't be much difference, but I wanted to keep things a bit more consistent and clean.

## Setup
```{r setup}
# working directory path
path.to.dir = "~/Documents/PNNL Analyses/GROWsed/"

# organizational
library(tidyverse)
library(ggpubr)
library(egg)
library(ggthemes)
library(ggridges)

# technical
library(readxl)
library(Rfast)

# analytical
library(rstatix)
library(vegan)
library(canprot)
library(WGCNA)

# custom function
raoQ = function(abund, trait, Hill = TRUE, scale = FALSE, method = "default") {
  
  abund <- as.matrix(abund)
  anames <- colnames(abund)[order(colnames(abund))]
  abund <- abund[, anames, drop = FALSE]
  
  trait <- as.matrix(trait)
  trait <- trait[anames, anames]
  
  if(ncol(abund) != ncol(trait))
    stop("Not all species in the abundance matrix appear in the trait matrix!") 
  
  abund <- abund / rowSums(abund)
  
  if(method == "default") 
    Q <- apply(abund, 1, function(x) crossprod(x, trait %*% x))
  
  if(method == "divc")
    Q <- apply(abund, 1, function(x) x %*% trait^2 %*% (x/2/sum(x)^2))
  
  if(Hill == TRUE) Q <- 1/(1 - Q)
  
  if(scale == TRUE) Q <- Q / max(Q)
  
  names(Q) <- rownames(abund)
  
  return(Q)
  
} # Copied from https://gist.github.com/jslefche/09756ff84afc7b6a82ea0582e663d098; by Jon Lefcheck

# specify functions
roebuck_set = function(mol){
  # Roebuck JA et al., 2022 - Geophyical Research Letters
  # https://agupubs.onlinelibrary.wiley.com/doi/full/10.1029/2022GL099535
  # modified from Seidel et al., 2015 - Marine Chemistry
  # https://www.sciencedirect.com/science/article/pii/S0304420315300049
  
  # empty object
  roebuck_set = rep(NA, nrow(mol))
  
  # boundaries
  roebuck_set[which(mol$AI_Mod >= 0.67 & mol$C >= 15)] = "Polycyclic"
  roebuck_set[which(mol$AI_Mod >= 0.67 & mol$C >= 15 & 
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "Polycyclic w/ Het."
  roebuck_set[which(mol$AI_Mod >= 0.67 & mol$C < 15 &
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "High Arom. (<15C)"
  roebuck_set[which(mol$AI_Mod >= 0.5 & mol$AI_Mod < 0.67)] = "Highly Arom. (e.g., polyphenols)"
  roebuck_set[which(mol$AI_Mod >= 0.5 & mol$AI_Mod < 0.67 &
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "Highly Arom. w/ Het."
  roebuck_set[which(mol$AI_Mod < 0.5 & mol$HtoC_ratio < 1.5)] = "Highly Unsat."
  roebuck_set[which(mol$AI_Mod < 0.5 & mol$HtoC_ratio < 1.5 &
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "Highly Unsat. w/ Het."
  roebuck_set[which(mol$HtoC_ratio >= 1.5 & mol$HtoC_ratio < 2)] = "Unsat. Aliph."
  roebuck_set[which(mol$HtoC_ratio >= 1.5 & mol$HtoC_ratio < 2 &
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "Unsat. Aliph. w/ Het. (e.g. peptides)"
  roebuck_set[which(mol$HtoC_ratio >= 2 & mol$OtoC_ratio < 0.9)] = "Sat. Compounds (e.g. lipids)"
  roebuck_set[which(mol$HtoC_ratio >= 2 & mol$OtoC_ratio < 0.9 &
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "Sat. Compounds w/ Het."
  roebuck_set[which(mol$HtoC_ratio >= 2 & mol$OtoC_ratio >= 0.9)] = "Sat. Compounds (e.g. carbohydrates)"
  roebuck_set[which(mol$mol$HtoC_ratio >= 2 & mol$OtoC_ratio >= 0.9 &
                      (mol$N > 0 | mol$S > 0 | mol$P > 0))] = "Carbohydrate-like w/ Het. (e.g. amino sugars)"
  
  # write out
  return(roebuck_set)
}

# knitr options
knitr::opts_knit$set(root.dir = path.to.dir)
knitr::opts_chunk$set(echo = TRUE)

# setting seed
set.seed(2414)

```

## Load in the protein files
```{r load-in}
# detect output file, if present
if(file.exists("GROWsurf Information/GROWsurf_Gene_CANPROT_Results.rds")){
  # print message
  print("Loading existing CANPROT results rather than regenerating them.")
  
  # load in existing file
  proteins = readRDS("GROWsurf Information/GROWsurf_Gene_CANPROT_Results.rds")
  
} else {
  # load translated genes file
  curr.fasta = read_fasta("GROWsurf Information/genes.translate.faa")
  
  # run canprot functions on the fasta
  proteins = data.frame(Protein = curr.fasta$protein,
                        Zc = Zc(curr.fasta), nH2O = nH2O(curr.fasta))
  
  # store object as an RDS
  saveRDS(proteins, "GROWsurf Information/GROWsurf_Gene_CANPROT_Results.rds")
  
  # remove curr.fasta
  rm(curr.fasta)
}

# load in annotations
annotations = read.table("GROWsurf Information/annotations.tsv", sep = "\t",
                         header = T, check.names = F, 
                         comment.char = "", quote = "")
colnames(annotations)[1] = "X"

# load in GROWtaxonomy file
tax = read.csv("GROWsurf Information/GROW_global_1286.csv") %>%
  dplyr::select(-Country)

# load in Nayfach taxonomy
tax = rbind(tax,
            read.csv("GROWsurf Information/Nayfach_GROWcompare_5336.csv") %>%
              dplyr::select(genome_id, ecosystem) %>%
              dplyr::rename(user_genome = genome_id,
                            classification = ecosystem))

# load in Garner taxonomy
tax = rbind(tax,
            read.csv("GROWsurf Information/Garner_GROWcompare_1008.csv") %>%
              mutate(domain = gsub("^", "d__", domain),
                     phylum = gsub("^", "p__", phylum),
                     class = gsub("^", "c__", class),
                     order = gsub("^", "o__", order),
                     family = gsub("^", "f__", family),
                     genus = gsub("^", "g__", genus),
                     species = gsub("^", "s__", species)) %>%
              mutate(class = case_when(is.na(class) ~ "c__",
                                       .default = class),
                     order = case_when(is.na(order) ~ "o__",
                                       .default = order),
                     family = case_when(is.na(family) ~ "f__",
                                        .default = family),
                     genus = case_when(is.na(genus) ~ "g__",
                                       .default = genus),
                     species = case_when(is.na(species) ~ "s__",
                                         .default = species)) %>%
              mutate(classification = paste0(domain, ";", phylum, ";", class,
                                             ";", order, ";", family, ";", genus,
                                             ";", species)) %>%
              dplyr::select(mag_id, classification) %>%
              dplyr::rename(user_genome = mag_id))

# load in Rodriguez-Ramos taxonomy
tax = rbind(tax,
            read.csv("GROWsurf Information/Rodriguez-Ramos_GROWcompare_75.csv") %>%
              dplyr::select(id, taxonomy) %>%
              dplyr::rename(user_genome = id,
                            classification = taxonomy))

# load in core GROWdb MAGs
tax = rbind(tax,
            read.csv("GROWsurf Information/GROWsurf_BacteriaGTDB_Kbase.csv") %>%
              dplyr::select(`User.Genome`, Classification) %>%
              dplyr::rename(user_genome = `User.Genome`,
                            classification = Classification) %>%
              dplyr::mutate(user_genome = gsub("bin_", "bin.", user_genome)) %>%
              dplyr::mutate(user_genome = gsub("_mag_as.*", "", user_genome)),
            read.csv("GROWsurf Information/GROWsurf_ArchaeaGTDB_Kbase.csv") %>%
              dplyr::select(`User.Genome`, Classification) %>%
              dplyr::rename(user_genome = `User.Genome`,
                            classification = Classification) %>%
              dplyr::mutate(user_genome = gsub("bin_", "bin.", user_genome)) %>%
              dplyr::mutate(user_genome = gsub("_mag_as.*", "", user_genome)))

# select taxonomies matching GROW MAGs
tax = tax[which(tax$user_genome %in% annotations$fasta),]

# split taxonomies
tax = data.frame(tax$user_genome,
                  do.call(rbind, str_split(tax$classification, pattern = ";")))
colnames(tax) = c("user_genome", "Domain", "Phylum", "Class", "Order", "Family",
                  "Genus", "Species")

# create column scheme
phy.col = c(RColorBrewer::brewer.pal(6,"Blues")[-1],
            RColorBrewer::brewer.pal(6,"Greens")[-1],
            RColorBrewer::brewer.pal(6,"Purples")[-1],
            RColorBrewer::brewer.pal(6,"Oranges")[-1],
            RColorBrewer::brewer.pal(6,"Greys")[-1])
names(phy.col) = unique(tax$Phylum)[order(unique(tax$Phylum))]
names(phy.col) = gsub("p__", "", names(phy.col))

# load in expression values
expression = read.csv("GROWsurf Information/GENES_geTMM_norm.counts.rpk_edger_zenodo.csv",
                      check.names = F)
names(expression) = gsub("_MT_.*", "", colnames(expression))
names(expression) = gsub("^.*S19S", "S19S", colnames(expression))
names(expression)[1] = "X"

# select expressed proteins
proteins.exp = proteins[which(proteins$Protein %in% expression$X),]
annotati.exp = annotations[which(annotations$X %in% expression$X),]

# load in factors
factors = read.csv("GROWsurf Information/GROWdb_with_vars_20220715.csv")

```

## Loading in FTICR data
```{r loading-in-icr-data}
# load in ICR data
data = read.csv("FTICR_Data/GROWsurf-Processed_Data.csv", row.names = 1,
                check.names = F) %>%
  rename_with(function(x) gsub(".corems", "", x))
mol = read.csv("FTICR_Data/GROWsurf-Processed_Mol.csv",
               check.names = F)

# filter out poorly calibrated samples
cal = read.csv("FTICR_Data/GROWsurf_CoreMS_Calibration_Results.csv",
               check.names = F) %>%
  filter(!`Cal. Points` < 3) %>%
  filter(!`Cal. RMS Error (ppm)` > 1.5)
data = data[,which(colnames(data) %in% cal$Sample)]

rm(cal)

# clean up missing peaks
mol = mol[-which(rowSums(data) == 0),]
data = data[-which(rowSums(data) == 0),]

# removing singletons (formulas found only in one site)
singletons = apply(data, 1, function(x) length(which(x > 0))) # identify
data = data[-which(singletons == 1),]
mol = mol[-which(singletons == 1),]

# store site sample count
site.count = table(gsub("_ICR.*", "", colnames(data)))

# aggregate formulas by stream order
agg.data = data %>% 
  rownames_to_column("Calibrated m/z") %>%
  gather(Sample, Intensity, -`Calibrated m/z`) %>%
  mutate(Site = gsub("_ICR.*", "", Sample)) %>%
  select(-Sample) %>%
  group_by(`Calibrated m/z`, Site) %>%
  summarise(Intensity = mean(Intensity)) %>%
  spread(key = Site, value = Intensity)

# convert to data frame
agg.data = data.frame(agg.data, row.names = 1, check.names = F)

# remove samples with only one rep
agg.data = agg.data[,-which(colnames(agg.data) %in% 
                              names(site.count)[site.count == 1])]

# match data to metaG factors
agg.data = agg.data[,which(colnames(agg.data) %in% 
                             gsub(".*S19S", "S19S", colnames(expression)))]

# calculate Roebuck's set
mol$Roebuck_Set = roebuck_set(mol)

# set masses as character identifiers
mol$`Calibrated m/z` = as.character(mol$`Calibrated m/z`)

# ensuring matching data
matching.samples = intersect(colnames(agg.data), colnames(expression))
agg.data = agg.data[,matching.samples]
expression = expression[,c("X", matching.samples)]

# confirm identity
if(!identical(colnames(agg.data), colnames(expression)[-1])){
  stop("Omic + ICR data don't match")
}

# clean up
rm(singletons, data, site.count)


```

## Summarizing DOM
```{r DOM-characteristics}
# metrics of interest
metrics = c("AI_Mod", "DBE_1", "NOSC", "OtoC_ratio", "HtoC_ratio", "NtoC_ratio",
            "PtoC_ratio", "NtoP_ratio")

# create average characteristics
mean.char = agg.data %>% rownames_to_column("Calibrated m/z") %>%
  gather(Sample, Intensity, -`Calibrated m/z`) %>%
  left_join(mol[,c("Calibrated m/z", metrics)], by = "Calibrated m/z") %>%
  gather(Variable, Value, -`Calibrated m/z`, -Sample, -Intensity) %>%
  filter(!Intensity == 0) %>%
  group_by(Sample, Variable) %>%
  summarise(Average = mean(Value, na.rm = T)) %>%
  spread(Variable, Average)

# add richness to average characteristics
mean.char = mean.char %>%
  left_join(data.frame(Sample = colnames(agg.data),
                       Diversity = sqrt(sqrt((apply(agg.data, 2, 
                                         function(x) length(which(x > 0))))))))

# create weighted characteristics
weight.char = agg.data %>% rownames_to_column("Calibrated m/z") %>%
  gather(Sample, Intensity, -`Calibrated m/z`) %>%
  left_join(mol[,c("Calibrated m/z", metrics)], by = "Calibrated m/z") %>%
  gather(Variable, Value, -`Calibrated m/z`, -Sample, -Intensity) %>%
  mutate(Weighted_Value = Intensity*Value) %>%
  group_by(Sample, Variable) %>%
  summarise(Weighted_Trait = sum(Weighted_Value, na.rm = T)/sum(Intensity)) %>%
  spread(Variable, Weighted_Trait)

# add Shannon's Diveristy to average characteristics
weight.char = weight.char %>%
  left_join(data.frame(Sample = colnames(agg.data),
                       Diversity = vegan::diversity(x = t(agg.data))))

# create empty object for molecular formula classes
class.sum = agg.data %>% rownames_to_column("Calibrated m/z") %>%
  gather(Sample, Intensity, -`Calibrated m/z`) %>%
  left_join(mol[,c("Calibrated m/z", "Roebuck_Set")], by = "Calibrated m/z") %>%
  mutate(Roebuck_Set = case_when(is.na(Roebuck_Set) ~ "Unassigned",
                                 .default = Roebuck_Set)) %>%
  filter(!Intensity == 0) %>%
  group_by(Sample, Roebuck_Set) %>%
  summarise(Count = n()) %>% ungroup() %>%
  group_by(Sample) %>%
  mutate(Count = (Count/sum(Count))*100) %>%
  spread(Roebuck_Set, Count)
class.sum[is.na(class.sum)] = 0

```

## Collapsing data by MAG
```{r organizing-by-MAG}
# summarize expression by MAGs
mag.exp = expression %>% left_join(annotati.exp[,1:2], by = "X") %>%
  select(-X) %>% group_by(fasta) %>%
  summarise_all(.funs = "sum")

# summarize CANPROT values by MAG
canprot.summary = proteins %>%
  left_join(annotations[,1:2], by = c("Protein" = "X")) %>%
  select(-Protein) %>% group_by(fasta) %>%
  summarise_all(.funs = "median") %>%
  mutate(Type = "Potential")

# summarize CANPROT values by expressed MAG
canprot.summary = rbind(canprot.summary,
                        proteins.exp %>%
                          left_join(annotations[,1:2], 
                                    by = c("Protein" = "X")) %>%
                          select(-Protein) %>% group_by(fasta) %>%
                          summarise_all(.funs = "median") %>%
                          mutate(Type = "Expressed"))

# add in taxonomic information to CANPROT summary
canprot.summary = canprot.summary %>%
  left_join(tax, by = c("fasta" = "user_genome"))

```


## Running WGCNA as for data reduction
```{r MAG WGCNA}
# WGCNA options
thresh = 0.15 # controlling export thresholds
sign = "signed" # controlling TOM sign
export = T # controlling export of networks
allowWGCNAThreads()

# replace cor with WGCNA cor
cor = WGCNA::cor

# thresholding
input = t(data.frame(mag.exp, row.names = 1))
sft = pickSoftThreshold(input, powerVector = c(1:20, seq(22, 30, by = 2)),
                        verbose = 5, RsquaredCut = 0.8,
                        networkType = "signed") # identifying threshold value
p = sft$powerEstimate # assigning predicted threshold
p = 10 # manually overriding the automatic assignment; graph looks more even
       # at 10

# automatic module detection
block = blockwiseModules(input, power = p, networkType = "signed",
                         TOMType = sign, minModuleSize = 20,
                         numericLabels = TRUE, corType = "pearson",
                         maxBlockSize = 12000) # main module detection function

if(export){
  # generating TOM matrix
  TOM = TOMsimilarity(adjacency(input, power = p, type = "signed"),
                      TOMType = sign) # calculates TOM; the correlations used in

  # exporting network for cytoscape
  dimnames(TOM) = list(colnames(input), colnames(input)) # name dimensions
  cyt = exportNetworkToCytoscape(TOM,
                                 edgeFile = paste0("GROWsurf Information/GROWsurf_Edges_",
                                                   thresh, "-thresh_", sign,
                                                   ".txt"),
                                 nodeFile = paste0("GROWsurf Information/GROWsurf_Nodes_",
                                                   thresh, "-thresh_", sign,
                                                   ".txt"),
                                 threshold = thresh)
  
  # creating a module list
  colors = data.frame(user_genome = names(block$colors),
                      Modules = paste0("ME", block$colors),
                      colors = labels2colors(block$colors))
  
  # adding in alternative colors
  mod.cols = data.frame(Modules = paste0("ME", 
                                         unique(block$colors)[
                                           order(unique(block$colors))]), 
                        AltColors = c("gray", 
                                      RColorBrewer::brewer.pal("Reds", 
                                                               n = 5)[-1], 
                                      RColorBrewer::brewer.pal("Blues", 
                                                               n = 5)[-1], 
                                      RColorBrewer::brewer.pal("Greens", 
                                                               n = 5)[-1],
                                      RColorBrewer::brewer.pal("Purples", 
                                                               n = 5)[-1]))
  colors = colors %>% left_join(mod.cols, by = "Modules")
  
  # adding metadata to module list
  colors = colors %>% 
    left_join(tax)
  
  # writing module list (without duplicates)
  write.table(colors, paste0("GROWsurf Information/GROWsurf_Modules_",
                             sign, ".txt"), 
              sep = "\t", row.names = F, quote = F)
  
}

# pulling out modules
MEs = block$MEs # eigengenes
AEs = moduleEigengenes(input, block$colors)$averageExpr # average expression

# identifying strongest module membership
ME.strength = NULL

for(curr.mod in colnames(MEs)){
  # select matching data
  temp.meta = colors %>%
    filter(Modules %in% curr.mod)
  
  # temporary genes from modules
  temp.data = data.frame(mag.exp[which(mag.exp$fasta %in% 
                                         temp.meta$user_genome),], 
                         row.names = 1)
  
  # correlate genes to module
  temp.corr = cor(t(temp.data),  
                  MEs[,which(colnames(MEs) %in% curr.mod)])
  
  # convert to data frame
  temp.corr = data.frame(user_genome = row.names(temp.corr), 
                         r_value = temp.corr)
  
  # merge into empty object
  ME.strength = rbind(ME.strength, temp.corr)
  
  # clean up
  rm(temp.meta, temp.data, temp.corr)
  
}

# add in module correlations to the ME.meta
tax = colors %>% left_join(ME.strength)

# clean up
rm(block, sft, p, curr.mod, ME.strength, colors, cyt, TOM, input,
   export, sign, thresh, mod.cols)

```

## Analyzing NOSC and nH2O by genome
```{r high-level-analysis}
# plot relationship between Zc + nH2O by phylum
plot1 = canprot.summary %>%
  # filter(Phylum %in% names) %>%
  mutate(Phylum = gsub("p__", "", Phylum)) %>%
  ggplot(aes(x = Zc, y = nH2O))+
  geom_point(aes(fill = Phylum), color = "black", size = 4, alpha = 0.75,
             pch = 21)+
  scale_fill_manual(values = phy.col)+
  facet_wrap(~Type, scales = "free")+
  theme_bw()
ggsave("Preliminary_Figures/GROWsurf_NOSC-nH2O_Relationship.pdf", plot1,
       width = 14)

# distributions of Zc + nH2O
plot2 = canprot.summary %>%
  # filter(Phylum %in% names) %>%
  mutate(Phylum = gsub("p__", "", Phylum)) %>%
  dplyr::select(Phylum, Zc, nH2O, Type) %>%
  gather(Variable, Value, -Phylum, -Type) %>%
  group_by(Phylum, Variable, Type) %>%
  mutate(Count = n()) %>% ungroup() %>%
  group_by(Phylum) %>%
  mutate(Count = min(Count)) %>%
  filter(Count >= 5) %>%
  mutate(Phylum = str_trunc(Phylum, 9, ellipsis = ".")) %>%
  ggplot(aes(x = Value, y = Type))+
  geom_density_ridges(aes(fill = Type), alpha = 0.75)+
  scale_fill_manual(values = c("firebrick", "dodgerblue"))+
  facet_grid(Phylum~Variable, scales = "free_x")+
  theme_bw()+
  theme(legend.position = "none")
ggsave("Preliminary_Figures/GROWsurf_Expr-Poten_CANPROT.pdf", plot2, 
       height = 10)

# difference in expressed vs. potential
plot3 = canprot.summary %>%
  group_by(fasta) %>%
  mutate(Count = n()) %>%
  filter(Count == 2) %>%
  mutate(delta_Zc = dist(Zc)) %>%
  mutate(delta_nH2O = dist(nH2O)) %>%
  select(fasta, Phylum, delta_nH2O, delta_Zc) %>%
  distinct() %>%
  mutate(Phylum = gsub("p__", "", Phylum)) %>%
  gather(Variable, Value, -Phylum, -fasta) %>%
  group_by(Phylum, Variable) %>%
  mutate(Count = n()) %>% ungroup() %>%
  group_by(Phylum) %>%
  mutate(Count = min(Count)) %>%
  filter(Count >= 5) %>%
  ggplot(aes(x = Value, y = Phylum))+
  geom_density_ridges(aes(fill = Phylum), alpha = 0.75)+
  scale_fill_manual(values = phy.col)+
  facet_grid(~Variable)+
  theme_bw()+
  theme(legend.position = "none")
ggsave("Preliminary_Figures/GROWsurf_CANPROT_deltas.pdf", plot3)

# clean up
rm(plot1, plot2, plot3)

```

## Analyzing nH2O and Zc by module
```{r canprot-module-analyses}
# taxonomic makeup of modules
tax %>% filter(r_value >= 0.5) %>%
  group_by(Modules, Phylum) %>%
  summarise(Count = n()) %>%
  filter(!Modules %in% "ME0") %>%
  mutate(Phylum = gsub("p__", "", Phylum)) %>%
  mutate(Modules = factor(Modules, 
                          levels = unique(tax$Modules[order(as.numeric(gsub("ME", "", tax$Modules)))]))) %>%
  ggplot(aes(x = Modules, y = Count))+
  geom_bar(stat = "identity", aes(fill = Phylum), color = "black", lwd = 0.1)+
  scale_fill_viridis_d()+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

# characteristics by module
canprot.summary %>%
  left_join(tax[,c("user_genome", "Modules", "r_value")], 
            by = c("fasta" = "user_genome")) %>%
  filter(r_value >= 0.5) %>%
  select(Modules, Zc, nH2O, Type) %>%
  gather(Metric, Value, -Modules, -Type) %>%
  filter(!Modules %in% "ME0") %>%
  filter(Type %in% "Expressed") %>%
  mutate(Modules = factor(Modules, 
                          levels = unique(tax$Modules[order(
                            as.numeric(gsub("ME", "", tax$Modules)))]))) %>%
  ggplot(aes(x = Modules, y = Value))+
  geom_boxplot(aes(fill = Type))+
  geom_pwc(method = "wilcox.test", hide.ns = T, label = "p.adj.signif",
    p.adjust.method = "fdr")+
  facet_grid(Metric~., scales = "free_y")+
  scale_fill_manual(values = c("#c44900", "#efd6ac"))+
  theme_bw()+
  theme(axis.text.x = element_text(angle = 90, hjust = 1, vjust = 0.5))

# characteristics by module
canprot.summary %>%
  left_join(tax[,c("user_genome", "Modules", "r_value")], 
            by = c("fasta" = "user_genome")) %>%
  filter(r_value >= 0.5) %>%
  select(Modules, Zc, nH2O, Type, fasta) %>%
  gather(Metric, Value, -Modules, -Type, -fasta) %>%
  pivot_wider(names_from = Type, values_from = Value) %>%
  mutate(Delta = abs(Potential - Expressed)) %>%
  filter(!Modules %in% "ME0") %>%
  mutate(Modules = factor(Modules, 
                          levels = unique(tax$Modules[order(
                            as.numeric(gsub("ME", "", tax$Modules)))]))) %>%
  ggplot(aes(x = Delta, y = Modules))+
  geom_density_ridges(quantile_lines = TRUE, quantiles = 2, alpha = 0.5)+
  facet_grid(.~Metric, scales = "free_x")+
  scale_x_continuous(expand = c(0, 0)) +
  scale_y_discrete(expand = c(0, 0)) +
  coord_cartesian(clip = "off") +
  theme_ridges()

```

## Relating modules to NOM
```{r module-eigen-to-thermo, fig.width=12, fig.height=17}
# correlating MEs to weighted traits
hist(cor(MEs, weight.char[,-1], method = "spearman"))

# plot eigenvalues against NOM characteristics
MEs %>%
  rownames_to_column("Sample") %>%
  mutate(Sample = gsub("^.*S19S", "S19S", Sample)) %>%
  gather(Modules, Eigengene, -Sample) %>%
  filter(!Modules %in% "ME0") %>%
  mutate(Modules = factor(Modules,
                          levels = unique(tax$Modules[order(
                            as.numeric(gsub("ME", "", tax$Modules)))]))) %>%
  left_join(weight.char) %>%
  gather(Metric, Value, -Modules, -Eigengene, -Sample) %>%
  ggplot(aes(x = Value, y = Eigengene))+
  geom_point()+
  geom_smooth(method = "lm", se = F)+
  stat_cor(method = "spearman", label.sep = "\n")+
  facet_grid(Modules~Metric, scales = "free_x")+
  theme_bw()

### It looks like there are not many relationships with the NOM principles, so
### I'm not pursuing any further statistical analysis.

# correlating MEs to weighted traits
hist(cor(MEs, class.sum[,-1], method = "spearman"))

# plotting modules against classes
MEs %>%
  rownames_to_column("Sample") %>%
  mutate(Sample = gsub("^.*S19S", "S19S", Sample)) %>%
  gather(Modules, Eigengene, -Sample) %>%
  filter(!Modules %in% "ME0") %>%
  mutate(Modules = factor(Modules,
                          levels = unique(tax$Modules[order(
                            as.numeric(gsub("ME", "", tax$Modules)))]))) %>%
  left_join(class.sum) %>%
  gather(Class, Value, -Modules, -Eigengene, -Sample) %>%
  filter(!Class %in% "Unassigned") %>%
  ggplot(aes(x = Value, y = Eigengene))+
  geom_point()+
  geom_smooth(method = "lm", se = F)+
  stat_cor(method = "spearman", label.sep = "\n")+
  facet_grid(Modules~Class, scales = "free_x")+
  theme_bw()

# in-depth correlations
MEs %>%
  rownames_to_column("Sample") %>%
  mutate(Sample = gsub("^.*S19S", "S19S", Sample)) %>%
  gather(Modules, Eigengene, -Sample) %>%
  filter(!Modules %in% "ME0") %>%
  mutate(Modules = factor(Modules,
                          levels = unique(tax$Modules[order(
                            as.numeric(gsub("ME", "", tax$Modules)))]))) %>%
  left_join(class.sum) %>%
  gather(Class, Value, -Modules, -Eigengene, -Sample) %>%
  filter(!Class %in% "Unassigned") %>%
  group_by(Modules, Class) %>%
  cor_test(Eigengene, Value, method = "spearman") %>%
  ungroup() %>% mutate(padj = p.adjust(p), method = "fdr") %>%
  filter(padj < 0.05)

```
## DOM WGCNA
```{r DOM-WGCNA}
# WGCNA options
thresh = 0.15 # controlling export thresholds
sign = "signed" # controlling TOM sign
export = T # controlling export of networks
allowWGCNAThreads()

# replace cor with WGCNA cor
cor = WGCNA::cor

# thresholding
input = t(agg.data)
sft = pickSoftThreshold(input, powerVector = c(1:20, seq(22, 30, by = 2)),
                        verbose = 5,
                        networkType = "signed") # identifying threshold value
p = sft$powerEstimate # assigning predicted threshold

# automatic module detection
block = blockwiseModules(input, power = p, networkType = "signed",
                         TOMType = sign, minModuleSize = 20,
                         numericLabels = TRUE, corType = "pearson",
                         maxBlockSize = 12000) # main module detection function

if(export){
  # generating TOM matrix
  TOM = TOMsimilarity(adjacency(input, power = p, type = "signed"),
                      TOMType = sign) # calculates TOM; the correlations used in

  # exporting network for cytoscape
  dimnames(TOM) = list(colnames(input), colnames(input)) # name dimensions
  cyt = exportNetworkToCytoscape(TOM,
                                 edgeFile = paste0("GROWsurf Information/GROWsurf_DOM_Edges_",
                                                   thresh, "-thresh_", sign,
                                                   ".txt"),
                                 nodeFile = paste0("GROWsurf Information/GROWsurf_DOM_Nodes_",
                                                   thresh, "-thresh_", sign,
                                                   ".txt"),
                                 threshold = thresh)
  
  # creating a module list
  colors = data.frame(`Calibrated m/z` = names(block$colors),
                      Modules = paste0("ME", block$colors),
                      colors = labels2colors(block$colors),
                      check.names = F)
  
  # adding metadata to module list
  colors = colors %>% left_join(mol)
  
  # writing module list (without duplicates)
  write.table(colors, paste0("GROWsurf Information/GROWsurf_DOM_Modules_",
                             sign, ".txt"), 
              sep = "\t", row.names = F, quote = F)
  
}


dom.mes = block$MEs

```

## Relate WGCNA modules
